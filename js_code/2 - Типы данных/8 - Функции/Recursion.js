// Суть рекурсии - это откладывание вычислений (хранение их в памяти), пока рекурсия не дойдет до базового случая. После этого уже все значения начинают исчисляться
// Факториал
const factorial = n => {
    if (n === 1){                        // Базовый случай (требование к остановке рекурсии)
        return 1
    }
    else{
        return n * factorial(n-1)        /* Шаг рекурсии
                                            Функция вызывает саму себя с новыми значениями - factorial(2). 
                                            В следующем вызове она опять вызывает саму себя с новым значением factorial(1). Зная что если n === 1, то return 1
                                            Созданные функции начинают "сворачиваться" - 3 * 2 * 1                                                             */ 
    }
}
alert(factorial(3))


//
const factorial = n => (n===1) ? 1 : n * factorial(n-1)
alert(factorial(5))


// Возведение в степень
const pow = (n, stepen) => {
    if (stepen === 1){
        return n
    }
    else {
        return n * pow(n, stepen - 1)
    }
} 
alert(pow(5,3))


// Итеративный процесс (мы не откладываем вычесление до тех пор, пока не будет известен базовый случай, а вычесляем по ходу). Длеается что бы вычесления происходили быстрее
const factorial = n => {
    const iter = (counter, acc) => {        
        if (counter === 0) {
            return acc;                                  // 2. Проверить базовый случай
        }
        return iter(counter - 1, counter * acc);         /* 3. Определть новое состояние 
                                                           Тут каждую итерацию мы записываем во второй аргумент функции новое значение, тем самым пересчитанное значение записывается 
                                                           каждую итерацию и не нужно ждать "сворачивания" */
    }
    return iter(n, 1)                                    // 1. Определить начальное состояние
}

factorial(5)




